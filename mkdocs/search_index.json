{
    "docs": [
        {
            "location": "/",
            "text": "Sejam Bem-vindos!!!\n\n\nEste \u00e9 um site e reposit\u00f3rio da Equipe Hawkings. Nele voc\u00ea encontrar\u00e1 informa\u00e7\u00f5es sobre o c\u00f3digo base de nossos projetos, tutoriais de constru\u00e7\u00e3o e programa\u00e7\u00e3o de drones aut\u00f4nomos e passo a passo de cursos dados pela equipe.\n\n\n\nAproveite! E caso tenha necessidade, entre em contato conosco pelas nossas redes sociais ou pelo email: \nhawkings.deg@ufla.br\n.",
            "title": "Home"
        },
        {
            "location": "/#sejam-bem-vindos",
            "text": "Este \u00e9 um site e reposit\u00f3rio da Equipe Hawkings. Nele voc\u00ea encontrar\u00e1 informa\u00e7\u00f5es sobre o c\u00f3digo base de nossos projetos, tutoriais de constru\u00e7\u00e3o e programa\u00e7\u00e3o de drones aut\u00f4nomos e passo a passo de cursos dados pela equipe.  Aproveite! E caso tenha necessidade, entre em contato conosco pelas nossas redes sociais ou pelo email:  hawkings.deg@ufla.br .",
            "title": " Sejam Bem-vindos!!!"
        },
        {
            "location": "/sobre/",
            "text": "Equipe Hawkings\n\n\nSomos uma equipe desenvolvedora de drones aut\u00f4nomos da Universidade Federal de Lavras. Desenvolvemos drones para aplica\u00e7\u00f5es em diversos setores da sociedade e para a participa\u00e7\u00e3o de competi\u00e7\u00f5es de drones aut\u00f4nomos no Brasil e no exterior.\n\n\n\nCriada no dia 1 de maio de 2018, a equipe \u00e9 formada por 4 setores: Gest\u00e3o, Hardware, Software e Mec\u00e2nica. Nosso trabalho inclui dimensionamento, constru\u00e7\u00e3o e programa\u00e7\u00e3o em sistemas embarcados, t\u00e9cnicas de controle, programa\u00e7\u00e3o paralela, simula\u00e7\u00f5es utilizando ROS, dentre outros.\n\n\n\nQuer conhecer um pouco mais sobre a equipe? Nos acompanhe nas nossa redes sociais ou nos enviem um e-mail, estamos \u00e0 disposi\u00e7\u00e3o sempre!\n\n\n\n\nE-mail: hawkings.deg@ufla.br\n\n\nInstagram: @equipehawkings\n\n\nLinkedin: Equipe Hawkings\n\n\nGithub: Equipe Hawkings",
            "title": "Sobre"
        },
        {
            "location": "/sobre/#equipe-hawkings",
            "text": "Somos uma equipe desenvolvedora de drones aut\u00f4nomos da Universidade Federal de Lavras. Desenvolvemos drones para aplica\u00e7\u00f5es em diversos setores da sociedade e para a participa\u00e7\u00e3o de competi\u00e7\u00f5es de drones aut\u00f4nomos no Brasil e no exterior.  Criada no dia 1 de maio de 2018, a equipe \u00e9 formada por 4 setores: Gest\u00e3o, Hardware, Software e Mec\u00e2nica. Nosso trabalho inclui dimensionamento, constru\u00e7\u00e3o e programa\u00e7\u00e3o em sistemas embarcados, t\u00e9cnicas de controle, programa\u00e7\u00e3o paralela, simula\u00e7\u00f5es utilizando ROS, dentre outros.  Quer conhecer um pouco mais sobre a equipe? Nos acompanhe nas nossa redes sociais ou nos enviem um e-mail, estamos \u00e0 disposi\u00e7\u00e3o sempre!   E-mail: hawkings.deg@ufla.br  Instagram: @equipehawkings  Linkedin: Equipe Hawkings  Github: Equipe Hawkings",
            "title": " Equipe Hawkings"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/",
            "text": "1\u00aa Parte: Tutoriais ROS\n\n\n\n\nInstala\u00e7\u00e3o da distribui\u00e7\u00e3o Melodic\n\n\n\n\nConfigurando o source.list\n\n\nConfigurando o computador para aceitar o software de \"packages.ros.org\".\n\n\nsudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list'\n\n\n\nConfigurando as keys\n\n\nsudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\n\n\n\nCaso esteja tendo problemas em conectar com o \nkeyserver\n, voc\u00ea pode tentar substiuindo \nhkp://pgp.mit.edu:80\n ou \nhkp://keyserver.ubuntu.com:80\n no comando anterior.\n\n\nAlternativamente, voc\u00ea pode usar o comando \ncurl\n ao inv\u00e9s do comando \napt-key\n. Podendo ser \u00fatil se estiver atr\u00e1s de um servidor proxy.\n\n\ncurl -sSL 'http://keyserver.ubuntu.com/pks/lookup?op=get&search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654' | sudo apt-key add -\n\n\n\nInstala\u00e7\u00e3o\n\n\nPrimeiramente, atualize seu pacote Debian\n\n\nsudo apt update\n\n\n\nAgora fa\u00e7a a instala\u00e7\u00e3o completa da distribui\u00e7\u00e3o. Nela est\u00e1 incluso: ROS, rqt, rviz, bibliotecas robot-generic, simuladores 2D/3D e percep\u00e7\u00e3o 2D/3D\n\n\nsudo apt install ros-melodic-desktop-full\n\n\n\nConfigurando o ambiente\n\n\n\u00c9 conveniente que as vari\u00e1veis do ambiente do ROS sejam automaticamente adicionadas \u00e0 sua sess\u00e3o \nbash\n sempre que uma nova \nshell\n \u00e9 inicializada.\n\n\necho \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc\nsource ~/.bashrc\n\n\n\nDepend\u00eancias para a \"build\" dos pacotes\n\n\n\u00c9 conveniente instalar ferramentas de comando que permitem que fa\u00e7a downloads de arquivos relacionados ao ROS mais facilmente, com apenas um comando.\n\n\n sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential\n\n\n\nAntes de utilizar essas ferramentas \u00e9 necess\u00e1rio iniciar o \nrosdep\n. Este permite que o sistema fa\u00e7a instala\u00e7\u00f5es de depend\u00eancias das fontes que deseja compilar e ele \u00e9 necess\u00e1rio para \"rodar\" alguns componentes do ROS.\n\n\nsudo apt install python-rosdep\nsudo rosdep init\n\n\nrosdep update\n\n\n\n\n\nInstala\u00e7\u00e3o e configura\u00e7\u00e3o do Ambiente do ROS\n\n\n\n\nCriando um Workspace para o ROS\n\n\nCriando e fazendo a \nbuild\n de um catkin workspace\n\n\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin_make\nsource devel/setup.bash\n\n\n\nPara ter certeza que seu workspace est\u00e1 propriamente configurado, tenha certeza que a vari\u00e1vel do ambiente \nROS_PACKAGE_PATH\n inclui o diret\u00f3rio em que voc\u00ea est\u00e1 no momento\n\n\necho $ROS_PACKAGE_PATH\n\n\n\n\n\nCriando e construindo uma Package\n\n\n\n\nCriando uma Package no catkin worskpace\n\n\nPara ser considerada uma Package, o diret\u00f3rio precisa conter os arquivos \npackage.xml\n e \nCMakeLists.txt\n.\n\n\n\nE para cria-la \u00e9 necess\u00e1rio especificar no comando \ncatkin_create_pkg\n o \nnome do pacote\n e a lista de depend\u00eancias.\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# catkin_create_pkg <nome_da_package> [depend\u00eancia1] [depend\u00eancia2] [depend\u00eancia3]\n\n\n\nPortanto, vamos criar uma Package chamada \ncurso\n.\n\n\ncd ~/catkin_ws/src\ncatkin_create_pkg curso std_msgs rospy roscpp\n\n\n\nRealizando a \"build\" e gerando uma fonte para o arquivo de \"setup\"\n\n\nFazendo a \nbuild\n das packages presentes no catkin workspace.\n\n\ncd ~/catkin_ws\ncatkin_make\n\n\n\n\n\nConhecendo ROS Nodes\n\n\n\n\nDownload de simuladores simples\n\n\nsudo apt-get install ros-melodic-ros-tutorials\n\n\n\nRoscore\n\n\nA primeira a\u00e7\u00e3o a ser feita sempre que for usar o ROS \u00e9 inicializar o Roscore\n\n\nroscore\n\n\n\nCaso o Roscore n\u00e3o inicialize e o terminal retorne uma mensagem sobre falta de permiss\u00f5es, mude recursivamente o \"dono\" da pasta\n\n\nsudo chown -R <seu_username> ~/.ros\n\n\n\nUtilizando o rosrun\n\n\nO comando rosrun permite que execute uma node em uma determinada package\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosrun [nome_da_package] [nome_da_node]\n\n\n\nAgora em um novo terminal, vamos executar a node chamada \nturtlesim_node\n que inicializa o simulador Turtle Sim.\n\n\nrosrun turtlesim turtlesim_node\n\n\n\nUtilizando o rosnode\n\n\nO comando \nrosnode\n mostra informa\u00e7\u00f5es sobre as nodes que est\u00e3o funcionando no momento.\n\n\n\nVoc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando (em um novo terminal):\n\n\nrosnode -h\n\n\n\n\n\nConhecendo ROS Topics\n\n\n\n\nControlando a tartaruguinha do Turtle Sim pelo teclado\n\n\nAinda com o Turtle Sim aberto, em um novo terminal execute a node chamada \nturtle_teleop_key\n.\n\n\nrosrun turtlesim turtle_teleop_key\n\n\n\nAgora voc\u00ea pode utilizar o teclado para movimentar a tartaruga. Mas para isso, \u00e9 necess\u00e1rio que a tela do terminal onde digitou o comando acima esteja selecionada.\n\n\nUtilizando o \nrqt_graph\n\n\nAs nodes \nturtlesim_node\n e \nturtle_teleop_key\n est\u00e3o comunicando uma com a outra por meio de um ROS Topic. \nturtle_teleop_key\n est\u00e1 \"publicando\" (\npublishing\n) as entradas em um Topic de quando acionamos o teclado, enquanto \nturtlesim_node\n est\u00e1 \"lendo\" ou \"inscrevendo\" (\nsubscribing\n) no mesmo Topic para receber o sinal do acionamento do teclado e realizar a a\u00e7\u00e3o no simulador.\n\n\n\nPodemos perceber isso utilizando o \nrqt_graph\n que foi instalado quando instalamos a distribui\u00e7\u00e3o Melodic. Ele possui a fun\u00e7\u00e3o de mostrar por meio de um gr\u00e1fico din\u00e2mico o que est\u00e1 acontecendo no sistema.\n\n \n\n\nEm um novo terminal digite:\n\n\nrosrun rqt_graph rqt_graph\n\n\n\nUtilizando o \nrostopic echo\n\n\nO comando \nrostopic\n mostra informa\u00e7\u00f5es sobre ROS Topics\n\n\n\nVoc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:\n\n\nrostopic -h\n\n\n\nrostopic echo\n mostra os dados publicados em um Topic\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic echo [topic]\n\n\n\nVamos observar os dados do \ncommand_velocity\n publicado pela node \nturtle_teleop_key\n.\n\n\nrostopic echo /turtle1/cmd_vel\n\n\n\nUtilizando o \nrostopic type\n\n\nO comando \nrostopic_type\n retorna o tipo da Message de qualquer Topic sendo publicado.\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic type [topic]\n\n\n\nAgora ent\u00e3o digite:\n\n\nrostopic type /turtle1/cmd_vel\n\n\n\nVoc\u00ea deve receber: \ngeometry_msgs/Twist\n. Com essa informa\u00e7\u00e3o, n\u00f3s conseguimos ver os detalhes da Message usando o comando \nrosmsg\n:\n\n\nrosmsg show geometry_msgs/Twist\n\n\n\nUtilizando o \nrostopic pub\n\n\nO comando \nrostopic pub\n publica algum dado em um Topic funcionando atualmente.\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic pub [topic] [msg_type] [argumentos]\n\n\n\nVamos enviar uma \u00fanica mensagem para o Turtle Sim dizendo a ele para se mover com uma velocidade linear de 2.0 e velocidade angular de 1.8.\n\n\nrostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'\n\n\n\nPodemos fazer com que a tartaruga continue se movimentando infinitamente adicionando \n-r\n no comando:\n\n\nrostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'\n\n\n\nUtilizando o \nrqt_plot\n\n\nO \nrqt_plot\n gera um gr\u00e1fico que mostra os dados publicados nos Topics ao longo do tempo:\n\n\nrosrun rqt_plot rqt_plot\n\n\n\nAdicione na caixa de texto os Topics \n/turtle1/pose/x\n e \n/turtle1/pose/y\n para ver no gr\u00e1fico as posi\u00e7\u00f5es da tartaruga no gr\u00e1fico ao longo do tempo.\n\n\n\n\nConhecendo ROS Services e Parameters\n\n\n\n\nUtilizando o \nrosservice call\n\n\nO comando \nrosservice\n mostra informa\u00e7\u00f5es sobre ROS Services\n\n\n\nVoc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:\n\n\nrosservice -h\n\n\n\nO \nrosservice call\n chama um Service com seus respectivos argumentos\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosservice call [service] [argumentos]\n\n\n\nVamos chamar um Service que limpa o fundo da node \nturtlesim_node\n. Esta a\u00e7\u00e3o n\u00e3o necessita de argumentos.\n\n\nrosservice call /clear\n\n\n\nAgora em um caso onde o Service possui argumentos. Vamos ver quais s\u00e3o eles:\n\n\nrosservice type /spawn | rossrv show\n\n\n\nEsse Service \n/spawn\n nos permite \"spawnar\" uma nova tartaruga em um dado local e orienta\u00e7\u00e3o. Agora que sabemos os argumentos necess\u00e1rios, vamos \"spawnar\" mais uma tartaruga no simulador:\n\n\nrosservice call /spawn 2 2 0.2 \"\"\n\n\n\nUtilizando o \nrosparam set\n e o \nrosparam get\n\n\nO comando \nrosparam\n mostra informa\u00e7\u00f5es sobre ROS Parameter Services e permite armazenar e manipular seus dados\n\n\n\nVoc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:\n\n\nrosparam -h\n\n\n\nO \nrosparam list\n mostra os par\u00e2metros da node \nturtlesim_node\n\n\nrosparam list\n\n\n\nAgora, podemos mudar e resgatar um dos valores utilizando o \nrosparam set\n e \nrosparam get\n respectivamente:\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosparam set [nome_do_par\u00e2metro]\n# rosparam get [nome_do_par\u00e2metro]\n\n\n\nVamos mudar o valor do \"red channel\" do sistema de cor RGB do plano de fundo do simulador:\n\n\nrosparam set /turtlesim/background_r 150\n\n\n\nPara que a mudan\u00e7a fa\u00e7a efeito \u00e9 necess\u00e1rio chamar o Service \nclear\n:\n\n\nrosservice call /clear\n\n\n\nE para visualizar o conte\u00fado do todo Parameter Server utilizamos:\n\n\nrosparam get /\n\n\n\n\n\nConhecendo o ROS Launch\n\n\n\n\nUtilizando o \nroslaunch\n\n\nO comando \nroslaunch\n inicializa nodes definidas em um launch file\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# roslaunch [package] [nome_do_arquivo.launch]\n\n\n\nPara uma maior organiza\u00e7\u00e3o vamos criar primeiramente um diret\u00f3rio chamado \"launch\" no qual armazenar\u00e1 os \"launch files\"\n\n\nsource devel/setup.bash\nroscd curso\nmkdir launch\ncd launch\n\n\n\nAgora criamos um launch file chamado \nturtlemimic.launch\n\n\ntouch turtlemimic.launch\n\n\n\nCopie e cole no arquivo o seguinte c\u00f3digo:\n\n\n<launch>\n\n  <group ns=\"turtlesim1\">\n        <node pkg=\"turtlesim\" name=\"sim\" type=\"turtlesim_node\"/>\n  </group>\n\n  <group ns=\"turtlesim2\">\n        <node pkg=\"turtlesim\" name=\"sim\" type=\"turtlesim_node\"/>\n  </group>\n\n  <node pkg=\"turtlesim\" name=\"mimic\" type=\"mimic\">\n    <remap from=\"input\" to=\"turtlesim1/turtle1\"/>\n    <remap from=\"output\" to=\"turtlesim2/turtle1\"/>\n  </node>\n\n</launch>\n\n\n\nVoc\u00ea pode editar o arquivo a partir do comando \nrosed\n abaixo. (Da mesma forma, abaixo est\u00e1 o comando de instala\u00e7\u00e3o do editor de texto Vim - editor padr\u00e3o do ROS)\n\n\nsudo apt install vim\nrosed curso turtlemimic.launch\n\n\n\nAp\u00f3s editado o arquivo, vamos execut\u00e1-lo.\n\n\nroslaunch curso turtlemimic.launch\n\n\n\nE em um novo terminal vamos digitar um novo comando \nrostopic\n\n\nrostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'\n\n\n\nPodemos entender como foi feito a \"m\u00edmica\" abrindo o \nrqt_graph\n\n\nrqt_graph\n\n\n\n\n\nCriando um ROS msg e srv\n\n\n\n\nCriando uma msg\n\n\nUma msg \u00e9 armazenada no diret\u00f3rio \"msg\" espec\u00edfico. Portanto, vamos criar um.\n\n\nsource devel/setup.bash\nroscd curso\nmkdir msg\ncd msg\n\n\n\nVamos agora criar e editar uma msg chamada \nNum.msg\n\n\ntouch Num.msg\nrosed curso Num.msg\n\n\n\nE cole as seguintes tipagens:\n\n\nint64 num\nstring first_name\nstring last_name\nuint8 age\nuint32 score\n\n\n\nEditando o \npackage.xml\n e \nCMakeLists.txt\n\n\nAp\u00f3s criada a msg, tenha certeza de que no arquivo \npackage.xml\n, as seguintes linhas n\u00e3o est\u00e3o comentadas\n\n\n<build_depend>message_generation</build_depend>\n<exec_depend>message_runtime</exec_depend>\n\n\n\nE no arquivo \nCMakeLists.txt\n, adicione a depend\u00eancia \nmessage generation\n para que as Messages possam ser geradas.\n\n\n\nVoc\u00ea pode fazer isso adicionando na lista de \nCOMPONENTS\n como mostrado abaixo:\n\n\n# N\u00e3o s\u00f3 adicione isso no arquivo, modifique o texto existente adicionando \"message_generation\" antes dos par\u00eanteses de fechamento.\nfind_package(catkin REQUIRED COMPONENTS\n    roscpp\n    rospy\n    std_msgs\n    message_generation\n)\n\n\n\nDa mesma forma, tenha certeza de que esteja exportando a execu\u00e7\u00e3o da depend\u00eancia (removendo o coment\u00e1rio e/ou adicionando as linhas abaixo):\n\n\ncatkin_package(\n...\nCATKIN_DEPENDS message_runtime ...\n...)\n\n\n\nAgora remova o coment\u00e1rio das linhas abaixo e substitua as \nMessage*.msg\n por \nNum.msg\n\n\n#Antes\n\n# add_message_files(\n#   FILES\n#   Message1.msg\n#   Message2.msg\n# )\n\n#Depois\n\nadd_message_files(\n  FILES\n  Num.msg\n)\n\n\n\nPor fim, precisamos garantir que a func\u00e7\u00e3o \ngenerate_messages ()\n \u00e9 chamada. Para isso, remova os coment\u00e1rios das seguintes linhas:\n\n\ngenerate_messages(\nDEPENDENCIES\nstd_msgs\n)\n\n\n\nTestando a msg criada\n\n\nVamos ter certeza de que o ROS possa reconhecer a msg usando o comando \nrosmsg show\n\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosmsg show [tipo da message]\n\n\n\nTestando ent\u00e3o:\n\n\nrosmsg show curso/Num\n\n\n\nVoc\u00ea receber\u00e1 como resposta:\n\n\nint64 num\nstring first_name\nstring last_name\nuint8 age\nuint32 score\n\n\n\nCriando um srv\n\n\nUma msg \u00e9 armazenada no diret\u00f3rio \"srv\" espec\u00edfico. Portanto, vamos criar um.\n\n\nroscd curso\nmkdir srv\ncd srv\n\n\n\nAo inv\u00e9s de criar um srv por n\u00f3s mesmos, vamos copiar um j\u00e1 existente de uma outra package.\n\n\n\nPara isso, o comando \nroscp\n \u00e9 \u00fatil para copiar arquivos de uma package a outra\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# roscp [nome_da_package] [arquivo_a_copiar] [local_do_arquivo_a_copiar]\n\n\n\nAgora podemos copiar um srv da package \nropsy_tutorials\n\n\nroscp rospy_tutorials AddTwoInts.srv AddTwoInts.srv\n\n\n\nEditando o \nCMake_Lists.txt\n\n\nA depend\u00eancia \nmessage_generation\n funciona tanto para msg quanto para srv, como anteriormente j\u00e1 foi configurada, n\u00e3o precisamos realiz\u00e1-la novamente.\n\n\n\nA mudan\u00e7a necess\u00e1ria ser\u00e1 a remo\u00e7\u00e3o dos coment\u00e1rios das linhas abaixo e a substitui\u00e7\u00e3o dos \nService*.srv\n por \nAddTwoInts.srv\n que \u00e9 o nome do srv copiado.\n\n\n#Antes\n\n# add_service_files(\n#   FILES\n#   Service1.srv\n#   Service2.srv\n# )\n\n#Depois\n\nadd_service_files(\n  FILES\n  AddTwoInts.srv\n)\n\n\n\nTestando o srv criado\n\n\nVamos ter certeza de que o ROS possa reconhecer o srv usando o comando \nrossrv show\n\n\n\n\nUsabilidade:\n\n\n# Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rossrv show [tipo do service]\n\n\n\nTestando ent\u00e3o:\n\n\nrossrv show curso/AddTwoInts\n\n\n\nVoc\u00ea receber\u00e1 como resposta:\n\n\nint64 a\nint64 b\n---\nint64 sum\n\n\n\nConstru\u00e7\u00e3o dos arquivos criados\n\n\nComo criou novas Messages e Services, precisamos fazer a \"build\" da nossa package novamente:\n\n\ncd\ncd catkin_ws\ncatkin_make\n\n\n\n\n\nEscrevendo um Publisher e Subscriber simples\n\n\n\n\nEscrevendo uma Publisher Node\n\n\nVamos criar uma node que ir\u00e1 continuamente transmitir uma Message. Para isso, vamos criar um diret\u00f3rio na nossa package onde ir\u00e1 conter os arquivos fontes ou \nsource files\n\n\nroscd curso\nmkdir -p src\ncd src\n\n\n\nVamos agora criar um arquivo chamado \ntalker.cpp\n retirado do site:\n\n\n\nhttps://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp\n\n\n\n\nDa mesma forma, vamos abri-lo para podermos analisar o c\u00f3digo presente e transforma-lo em um arquivo execut\u00e1vel.\n\n\nwget https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp\nchmod +x talker.cpp\nrosed curso talker.cpp\n\n\n\nCaso recebam algum tipo de aviso, role a p\u00e1gina at\u00e9 o final e tecle o bot\u00e3o \"a\" no seu teclado para que possam visualizar o c\u00f3digo\n\n\nAnalisando a Publisher\n\n\nAgora vamos entender o c\u00f3digo\n\n\n27 #include \"ros/ros.h\"\n28\n\n\n\nros/ros.h\n \u00e9 uma conveniente inclus\u00e3o que inclui todas as \nheaders\n necess\u00e1rias para usar as pe\u00e7as p\u00fablicas mais comuns do sistema do ROS\n\n\n28 #include \"std_msgs/String.h\"\n29\n\n\n\nAs linhas acima incluem a Message \nstd_msgs/String\n que reside na package \nstd_msgs\n. Essa \u00e9 uma \nheader\n gerada automaticamente pelo arquivo \nString.msg\n presente na package\n\n\n47   ros::init(argc, argv, \"talker\");\n\n\n\nInicializa o ROS. \u00c9 onde tamb\u00e9m especificamos o nome da nossa node. (Nomes de nodes precisam ser \u00fanicas em um sistema a funcionar)\n\n\n54   ros::NodeHandle n;\n\n\n\nCria um manipulador ou \nhandle\n para o processamento da node. O primeiro \nNodeHandle\n criado vai inicializar a node e o \u00faltimo ir\u00e1 destru\u00ed-la limpando os recursos que a node estava usando\n\n\n73   ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);\n\n\n\nDiz para o Master que estaremos publicando uma Message do tipo \nstd_msgs/String\n no Topic \nchatter\n. Permite que o Master diga a qualquer node \"escutando\" no Topic \nchatter\n que estaremos publicando dados nesse t\u00f3pico. O segundo argumento, \u00e9 o tamanho da fila que estamos publicando. Nesse caso, se estamos publicando muito rapidamente, ele ir\u00e1 \"buffar\" no m\u00e1ximo 1000 Messages antes de come\u00e7ar a descartar as antigas.\n\n\n\nNodeHandle::advertise()\n retorna um objeto \nros::Publisher\n que serve para dois prop\u00f3sitos:\n\n\n\n\nConter um m\u00e9todo \npublish()\n que permite que publiquemos Messages dentro do t\u00f3pico que foi criado junto\n\n\n\n\nQuando sair do escopo, ir\u00e1 automaticamente desavisar (\nunadvertise\n)\n\n\n75   ros::Rate loop_rate(10);\n\n\n\n\n\n\nUm objeto \nros::Rate\n permite especificar a frequ\u00eancia que voc\u00ea gostaria que o ciclo possua. Ele ir\u00e1 verificar quanto tempo se passou at\u00e9 que a \u00faltima chamada ao \nros::sleep()\n foi feita. Da mesma forma, \"dorme\" (\nsleep\n) por um correta quantidade de tempo.\n\n\n\nNesse caso, dizemos a ele que queremos funcionar a 10Hz.\n\n\n81   int count = 0;\n82   while (ros::ok())\n83   {\n\n\n\nPor padr\u00e3o, \nroscpp\n instalar\u00e1 um manipulador SIGINT que providenciar\u00e1 o desligamento da manipula\u00e7\u00e3o, que no caso ir\u00e1 causar \nros::ok()\n retornar falso.\n\n\n\nros::ok()\n retornar\u00e1 falso se:\n\n\n\n\nUm SIGINT \u00e9 recebido;\n\n\nFomos expulsos da rede por uma outra node de mesmo nome;\n\n\nros::shutdown()\n foi chamado por outra parte da aplica\u00e7\u00e3o;\n\n\nTodos os \nros::NodeHandles\n foram destru\u00eddos.\n\n\n\n\nUma vez que \nros::ok\n retorne falso, todas as chamadas do ROS ir\u00e3o falhar\n\n\n87     std_msgs::String msg;\n88 \n89     std::stringstream ss;\n90     ss << \"hello world \" << count;\n91     msg.data = ss.str();\n\n\n\nTransmitimos uma mensagem no ROS usando uma classe de mensagens-adaptadas, usualmente gerada por um arquivo msg. \n\n\n\ndatatypes\n mais complicados s\u00e3o poss\u00edveis, mas por agora iremos usar uma Message String padr\u00e3o, que possui um membro \"dado\".\n\n\n101     chatter_pub.publish(msg);\n\n\n\nAgora n\u00f3s estamos realmente transmitindo a Message a todos que est\u00e3o conectados\n\n\n93     ROS_INFO(\"%s\", msg.data.c_str());\n\n\n\nROS_INFO\n e amigos s\u00e3o os os nossos substitutos para o \nprintf/cout\n\n\n103     ros::spinOnce();\n\n\n\nChamando o \nros::spinOnce()\n aqui, n\u00e3o \u00e9 necess\u00e1rio para este programa simples pois n\u00e3o estamos recebendo nenhum \ncallback\n. Entretanto, se voc\u00ea for adicionar uma \"subscription\" nessa aplica\u00e7\u00e3o, e n\u00e3o tem o \nros::spinOnce()\n aqui, seus \ncallbacks\n nunca ser\u00e3o chamados. Ent\u00e3o , adicion\u00e1-lo \u00e9 uma boa medida\n\n\n105     loop_rate.sleep();\n\n\n\nAgora usamos o objeto \nros::Rate\n para \"dormir\" (\nsleep\n) pelo tempo restante que nos permite alcan\u00e7ar a taxa de \"publish\" de 10Hz desejada.\n\n\n\nAbaixo h\u00e1 uma vers\u00e3o condensada do que est\u00e1 acontecendo\n\n\n\n\nInicializa o sistema do ROS\n\n\nAvisa se vamos publicar Messages \nstd_msgs/String\n no Topic \nchatter\n para o Master\n\n\n\"Loop\" enquanto publicamos Messages ao \nchatter\n 10 vezes por segundo\n\n\n\n\nEscrevendo um Subscriber Node\n\n\nAgora precisamos escrever uma Node que receba as Messages\n\n\n\nDentro do diret\u00f3rio src anteriormente criado vamos criar um arquivo chamado \nlistener.cpp\n retirado do site:\n\n\n\nhttps://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp\n\n\n\n\nDa mesma forma, vamos abri-lo para podermos analisar o c\u00f3digo presente e transforma-lo em um arquivo execut\u00e1vel.\n\n\nwget https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp\nchmod +x listener.cpp\nrosed curso listener.cpp\n\n\n\nCaso recebam algum tipo de aviso, role a p\u00e1gina at\u00e9 o final e tecle o bot\u00e3o \"a\" no seu teclado para que possam visualizar o c\u00f3digo\n\n\nAnalisando o Subscriber\n\n\nVamos analisar o c\u00f3digo ignorando algumas partes que j\u00e1 foram explicadas anteriormente\n\n\n34 void chatterCallback(const std_msgs::String::ConstPtr& msg)\n35 {\n36   ROS_INFO(\"I heard: [%s]\", msg->data.c_str());\n37 }\n\n\n\nEssa \u00e9 a fun\u00e7\u00e3o de \ncallback\n que ser\u00e1 chamada quando uma nova Message chegar no Topic \nchatter\n. A Message \u00e9 passada em um \nboost shared_ptr\n que significa que voc\u00ea pode armazen\u00e1-lo se quiser, sem preocupar se est\u00e1 sendo deletado abaixo de voc\u00ea e sem copiar o dado subjacente.\n\n\n75   ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback);\n\n\n\n\"Subscribe\" no Topic \nchatter\n com o Master. ROS ir\u00e1 chamar a fun\u00e7\u00e3o \nchatterCallback()\n sempre que uma nova mensagem chega. O segundo argumento \u00e9 o tamanho da fila, no caso de n\u00e3o ser poss\u00edvel processar Messages r\u00e1pido o suficiente. Nesse caso, se a fila chega a 1000 Messages, come\u00e7aremos a descartar velhas Messages enquanto novas chegam.\n\n\n\nNodeHandle::subscribe()\n retorna um objeto \nros::Subscriber\n que voc\u00ea precisa manter at\u00e9 o momento que desejar se desinscrever (\nunsubscribe\n). Quando o objeto Subscriber \u00e9 destru\u00eddo, ele ir\u00e1 automaticamente se desinscrever do Topic \nchatter\n\n\n\n\nExistem vers\u00f5es da fun\u00e7\u00e3o \nNodeHandle::subscribe()\n que permite especificar membros da classe, ou at\u00e9 qualquer coisa capaz de ser chamada pelo objeto \nBoost.Function\n\n\n82   ros::spin();\n\n\n\nros::spin()\n entra em um loop, chamando \ncallbacks\n de Messages o mais r\u00e1pido poss\u00edvel. Mas n\u00e3o se preocupe, se n\u00e3o existe nada a ser feito ele n\u00e3o ir\u00e1 usar muita CPU. \nros::spin()\n ir\u00e1 sair uma vez que \nros::ok()\n retorne falso, o que significa que \nros::shutdown()\n foi chamado, ou pelo \nhandler\n de desligamento (o Master nos dizendo para desligar), ou sendo chamado manualmente.\n\n\n\nExistem outras formas de puxar \ncallbacks\n, mas n\u00e3o iremos preocupar com elas por agora.\n\n\n\nNovamente, abaixo est\u00e1 uma vers\u00e3o condensada do que est\u00e1 acontecendo:\n\n\n\n\nInicia o sistema do ROS;\n\n\nSe inscreve no Topic \nchatter\n;\n\n\n\"Spin\", esperando a chegada de Messages;\n\n\nQuando uma Message chega, a fun\u00e7\u00e3o \nchatterCallback()\n\u00e9 chamada.\n\n\n\n\nConstruindo as Nodes\n\n\nEditando novamente o arquivo \nCMakeLists.txt\n, retirando coment\u00e1rios e adicionando linhas de c\u00f3digo, o conte\u00fado deve estar mais ou menos assim: \n\n\n\n(Mantendo as modifica\u00e7\u00f5es feitas nos passos anteriores)\n\n\ncmake_minimum_required(VERSION 2.8.3)\nproject(curso)\n\n## Find catkin and any catkin packages\nfind_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation)\n\n## Declare ROS messages and services\nadd_message_files(FILES Num.msg)\nadd_service_files(FILES AddTwoInts.srv)\n\n## Generate added messages and services\ngenerate_messages(DEPENDENCIES std_msgs)\n\n## Declare a catkin package\ncatkin_package()\n\n## Build talker and listener\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(talker src/talker.cpp)\ntarget_link_libraries(talker ${catkin_LIBRARIES})\nadd_dependencies(talker curso_generate_messages_cpp)\n\nadd_executable(listener src/listener.cpp)\ntarget_link_libraries(listener ${catkin_LIBRARIES})\nadd_dependencies(listener curso_generate_messages_cpp)\n\n\n\nAs \u00faltimas 6 linhas de c\u00f3digo adicionadas ir\u00e3o criar dois execut\u00e1veis, \ntalker\n e \nlistener\n que por padr\u00e3o ir\u00e3o para o diret\u00f3rio \ndevel\n\n\n\n\nNote que voce teve que adicionar duas depend\u00eancias para os \"executable targets\" aos \"message generation targets\"\n\n\nadd_dependencies(talker curso_generate_messages_cpp)\n\n\n\nIsso garante que as \"messages headers\" dessa package sejam geradas antes de us\u00e1-las. Se voc\u00ea usar Messages de outras Packages de dentro do seu catkin workspace, voc\u00ea precisa adicionar depend\u00eancias para os seus respectivos \"generations targets\" tamb\u00e9m, pois o catkin constroi todos os projetos em paralelo. Assim como \nGroovy\n voc\u00ea pode usar a seguinte vari\u00e1vel para depender de todos os alvos necess\u00e1rios:\n\n\ntarget_link_libraries(talker ${catkin_LIBRARIES})\n\n\n\nEnt\u00e3o agora voc\u00ea pode faze a \"build\"\n\n\ncd\ncd catkin_ws\ncatkin_make\n\n\n\nTestando o Publisher e Subscriber criados\n\n\nTenha certeza que roscore esteja ativo. Em um novo terminal\n\n\nroscore\n\n\n\nTenha certeza que fez a \"source\" do seu arquivo do workspace \nsetup.sh\n\n\ncd\ncd catkin_ws\nsource devel/setup.bash\n\n\n\nVamos agora testar o Publisher \ntalker\n\n\nrosrun curso talker\n\n\n\nVoc\u00ea ir\u00e1 receber algo parecido com isso:\n\n\n[INFO] [WallTime: 1314931831.774057] hello world 1314931831.77\n[INFO] [WallTime: 1314931832.775497] hello world 1314931832.77\n[INFO] [WallTime: 1314931833.778937] hello world 1314931833.78\n[INFO] [WallTime: 1314931834.782059] hello world 1314931834.78\n[INFO] [WallTime: 1314931835.784853] hello world 1314931835.78\n[INFO] [WallTime: 1314931836.788106] hello world 1314931836.79\n\n\n\nAgora em um novo terminal, vamos testar o Subscriber \nlistener\n\n\nrosrun curso listener\n\n\n\nVoc\u00ea receber\u00e1 algo parecido com isso:\n\n\n[INFO] [WallTime: 1314931969.258941] /listener_17657_1314931968795I heard hello world 1314931969.26\n[INFO] [WallTime: 1314931970.262246] /listener_17657_1314931968795I heard hello world 1314931970.26\n[INFO] [WallTime: 1314931971.266348] /listener_17657_1314931968795I heard hello world 1314931971.26\n[INFO] [WallTime: 1314931972.270429] /listener_17657_1314931968795I heard hello world 1314931972.27\n[INFO] [WallTime: 1314931973.274382] /listener_17657_1314931968795I heard hello world 1314931973.27\n[INFO] [WallTime: 1314931974.277694] /listener_17657_1314931968795I heard hello world 1314931974.28\n[INFO] [WallTime: 1314931975.283708] /listener_17657_1314931968795I heard hello world 1314931975.28\n\n\n\nAp\u00f3s feitos os testes pode apertar Ctrl-C para finalizar ambas as Nodes.\n\n\n\n\nEscrevendo um Service e Client simples\n\n\n\n\nEscrevendo um Service Node\n\n\nVamos criar um Service Node \nadd_two_ints_server\n que receber\u00e1 dois inteiros e retorna a soma. Ele estar\u00e1 armazenado no diret\u00f3rio src criado nos passos anteriores.\n\n\nroscd curso/src\ntouch add_two_ints_server.cpp\n\n\n\nAgora vamos edit\u00e1-lo e transforma-lo em um arquivo execut\u00e1vel.\n\n\nchmod +x add_two_ints_server.cpp\nrosed curso add_two_ints_server.cpp\n\n\n\nCole o seguinte c\u00f3digo no arquivo:\n\n\n#include \"ros/ros.h\"\n#include \"curso/AddTwoInts.h\"\n\nbool add(curso::AddTwoInts::Request  &req,\n         curso::AddTwoInts::Response &res)\n{\n  res.sum = req.a + req.b;\n  ROS_INFO(\"request: x=%ld, y=%ld\", (long int)req.a, (long int)req.b);\n  ROS_INFO(\"sending back response: [%ld]\", (long int)res.sum);\n  return true;\n}\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"add_two_ints_server\");\n  ros::NodeHandle n;\n\n  ros::ServiceServer service = n.advertiseService(\"add_two_ints\", add);\n  ROS_INFO(\"Ready to add two ints.\");\n  ros::spin();\n\n  return 0;\n}\n\n\n\nAnalisando o Service\n\n\nVamos agora entender o c\u00f3digo\n\n\n1 #include \"ros/ros.h\"\n2 #include \"curso/AddTwoInts.h\"\n3\n\n\n\ncurso/AddTwoInts.h\n \u00e9 o arquivo \nheader\n gerado do arquivo srv que criamos nos passos anteriores.\n\n\n4 bool add(curso::AddTwoInts::Request  &req,\n5          curso::AddTwoInts::Response &res)\n\n\n\nEssa fun\u00e7\u00e3o providencia o Service que adiciona dois inteiros. Ele recebe o tipo de \"solicita\u00e7\u00e3o\" (\nrequest\n) e de \"resposta\" (\nresponse\n) definido no arquivo srv e retorna um booleano.\n\n\n6 {\n7   res.sum = req.a + req.b;\n8   ROS_INFO(\"request: x=%ld, y=%ld\", (long int)req.a, (long int)req.b);\n9   ROS_INFO(\"sending back response: [%ld]\", (long int)res.sum);\n10   return true;\n11 }\n\n\n\nAcima, os dois inteiros s\u00e3o adicionados e armazenados na \"resposta\". Depois, algumas informa\u00e7\u00f5es sobre a \"solicita\u00e7\u00e3o\" e a \"resposta\" s\u00e3o registrados. Por fim, o Service retorna verdadeiro quando completo\n\n\n18   ros::ServiceServer service = n.advertiseService(\"add_two_ints\", add);\n\n\n\nAcima, o Service \u00e9 criado e anunciado sobre o ROS\n\n\nEscrevendo um Client Node\n\n\nVamos criar um Service Node \nadd_two_ints_client\n. Ele estar\u00e1 armazenado novamente no diret\u00f3rio src.\n\n\n\nroscd curso/src\ntouch add_two_ints_client.cpp\n\n\n\nAgora vamos edit\u00e1-lo e transforma-lo em um arquivo execut\u00e1vel\n\n\nchmod +x add_two_ints_client.cpp\nrosed curso add_two_ints_client.cpp\n\n\n\nCole o seguinte c\u00f3digo no arquivo:\n\n\n#include \"ros/ros.h\"\n#include \"curso/AddTwoInts.h\"\n#include <cstdlib>\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"add_two_ints_client\");\n  if (argc != 3)\n  {\n    ROS_INFO(\"usage: add_two_ints_client X Y\");\n    return 1;\n  }\n\n  ros::NodeHandle n;\n  ros::ServiceClient client = n.serviceClient<curso::AddTwoInts>(\"add_two_ints\");\n  curso::AddTwoInts srv;\n  srv.request.a = atoll(argv[1]);\n  srv.request.b = atoll(argv[2]);\n  if (client.call(srv))\n  {\n    ROS_INFO(\"Sum: %ld\", (long int)srv.response.sum);\n  }\n  else\n  {\n    ROS_ERROR(\"Failed to call service add_two_ints\");\n    return 1;\n  }\n\n  return 0;\n}\n\n\n\nAnalisando o Client\n\n\nVamos agora entender o c\u00f3digo\n\n\n15   ros::ServiceClient client = n.serviceClient<curso::AddTwoInts>(\"add_two_ints\");\n\n\n\nA linha acima cria um Client para o Service \nadd_two_ints\n. O objeto \nros::ServiceClient\n \u00e9 usado para chamar o Service posteriormente\n\n\n16   curso::AddTwoInts srv;\n17   srv.request.a = atoll(argv[1]);\n18   srv.request.b = atoll(argv[2]);\n\n\n\nAcima, n\u00f3s instaciamos um Service Class que se \"autogera\" e atribui valores dentro de seu membro de \"solicita\u00e7\u00e3o\". Um Service Class cont\u00e9m dois membros, \nrequest\n e \nresponse\n. Ele da mesma forma cont\u00e9m duas defini\u00e7\u00f5es de classe \nRequest\n e \nResponse\n.\n\n\n19   if (client.call(srv))\n\n\n\nA linha acima realmente chama o Service. Desde que as chamadas do Service s\u00e3o bloqueadas, ele retornar\u00e1 uma vez que a chamada \u00e9 finalizada. Se a chamada do Service for bem sucedida, \ncall()\n ir\u00e1 retornar verdadeiro e o valor em \nsrv.response\n ser\u00e1 valido. Se a chamada n\u00e3o for bem sucedida , \ncall()\n retornar\u00e1 falso e o valor em \nsrv.response\n ser\u00e1 inv\u00e1lido.\n\n\nConstruindo as Nodes\n\n\nNovamente, ser\u00e1 necess\u00e1rio editar o arquivo \nCMakeLists.txt\n, adicionando no final do arquivo o seguinte c\u00f3digo:\n\n\nadd_executable(add_two_ints_server src/add_two_ints_server.cpp)\ntarget_link_libraries(add_two_ints_server ${catkin_LIBRARIES})\nadd_dependencies(add_two_ints_server curso_gencpp)\n\nadd_executable(add_two_ints_client src/add_two_ints_client.cpp)\ntarget_link_libraries(add_two_ints_client ${catkin_LIBRARIES})\nadd_dependencies(add_two_ints_client curso_gencpp)\n\n\n\nAs linhas acima ir\u00e3o criar dois execut\u00e1veis, \nadd_two_ints_server\n e \nadd_two_ints_client\n que por padr\u00e3o ir\u00e3o para seu diret\u00f3rio \ndevel\n.\n\n\n\nAgora, podemos fazer a \"build\" novamente\n\n\ncd\ncd catkin_ws\ncatkin_make\n\n\n\nTestando o Service e Client criados\n\n\nTenha certeza que roscore esteja ativo. Em um novo terminal\n\n\nroscore\n\n\n\nTenha certeza que fez a \"source\" do seu arquivo do workspace \nsetup.sh\n\n\ncd catkin_ws\nsource devel/setup.bash\n\n\n\nVamos agora testar o server\n\n\nrosrun curso add_two_ints_server\n\n\n\nVoc\u00ea ir\u00e1 receber algo parecido com isso:\n\n\nReady to add two ints.\n\n\n\nAgora em um outro terminal, vamos colocar para funcionar o client com os argumentos necess\u00e1rios\n\n\nrosrun curso add_two_ints_client 1 3\n\n\n\nNo terminal do client, voc\u00ea ir\u00e1 receber algo parecido com isso:\n\n\nSum: 4\n\n\n\nE no terminal do server, algo parecido com isso:\n\n\nrequest: x=1, y=3\nsending back response: [4]",
            "title": "Introdu\u00e7\u00e3o ao ROS e Gazebo"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#1a-parte-tutoriais-ros",
            "text": "",
            "title": "1\u00aa Parte: Tutoriais ROS"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#instalacao-da-distribuicao-melodic",
            "text": "",
            "title": "Instala\u00e7\u00e3o da distribui\u00e7\u00e3o Melodic"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#configurando-o-sourcelist",
            "text": "Configurando o computador para aceitar o software de \"packages.ros.org\".  sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list'",
            "title": "Configurando o source.list"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#configurando-as-keys",
            "text": "sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654  Caso esteja tendo problemas em conectar com o  keyserver , voc\u00ea pode tentar substiuindo  hkp://pgp.mit.edu:80  ou  hkp://keyserver.ubuntu.com:80  no comando anterior.  Alternativamente, voc\u00ea pode usar o comando  curl  ao inv\u00e9s do comando  apt-key . Podendo ser \u00fatil se estiver atr\u00e1s de um servidor proxy.  curl -sSL 'http://keyserver.ubuntu.com/pks/lookup?op=get&search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654' | sudo apt-key add -",
            "title": "Configurando as keys"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#instalacao",
            "text": "Primeiramente, atualize seu pacote Debian  sudo apt update  Agora fa\u00e7a a instala\u00e7\u00e3o completa da distribui\u00e7\u00e3o. Nela est\u00e1 incluso: ROS, rqt, rviz, bibliotecas robot-generic, simuladores 2D/3D e percep\u00e7\u00e3o 2D/3D  sudo apt install ros-melodic-desktop-full",
            "title": "Instala\u00e7\u00e3o"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#configurando-o-ambiente",
            "text": "\u00c9 conveniente que as vari\u00e1veis do ambiente do ROS sejam automaticamente adicionadas \u00e0 sua sess\u00e3o  bash  sempre que uma nova  shell  \u00e9 inicializada.  echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc\nsource ~/.bashrc",
            "title": "Configurando o ambiente"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#dependencias-para-a-build-dos-pacotes",
            "text": "\u00c9 conveniente instalar ferramentas de comando que permitem que fa\u00e7a downloads de arquivos relacionados ao ROS mais facilmente, com apenas um comando.   sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential  Antes de utilizar essas ferramentas \u00e9 necess\u00e1rio iniciar o  rosdep . Este permite que o sistema fa\u00e7a instala\u00e7\u00f5es de depend\u00eancias das fontes que deseja compilar e ele \u00e9 necess\u00e1rio para \"rodar\" alguns componentes do ROS.  sudo apt install python-rosdep\nsudo rosdep init\n\n\nrosdep update",
            "title": "Depend\u00eancias para a \"build\" dos pacotes"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#instalacao-e-configuracao-do-ambiente-do-ros",
            "text": "",
            "title": "Instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ambiente do ROS"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-um-workspace-para-o-ros",
            "text": "Criando e fazendo a  build  de um catkin workspace  mkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin_make\nsource devel/setup.bash  Para ter certeza que seu workspace est\u00e1 propriamente configurado, tenha certeza que a vari\u00e1vel do ambiente  ROS_PACKAGE_PATH  inclui o diret\u00f3rio em que voc\u00ea est\u00e1 no momento  echo $ROS_PACKAGE_PATH",
            "title": "Criando um Workspace para o ROS"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-e-construindo-uma-package",
            "text": "",
            "title": "Criando e construindo uma Package"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-uma-package-no-catkin-worskpace",
            "text": "Para ser considerada uma Package, o diret\u00f3rio precisa conter os arquivos  package.xml  e  CMakeLists.txt .  E para cria-la \u00e9 necess\u00e1rio especificar no comando  catkin_create_pkg  o  nome do pacote  e a lista de depend\u00eancias.  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# catkin_create_pkg <nome_da_package> [depend\u00eancia1] [depend\u00eancia2] [depend\u00eancia3]  Portanto, vamos criar uma Package chamada  curso .  cd ~/catkin_ws/src\ncatkin_create_pkg curso std_msgs rospy roscpp",
            "title": "Criando uma Package no catkin worskpace"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#realizando-a-build-e-gerando-uma-fonte-para-o-arquivo-de-setup",
            "text": "Fazendo a  build  das packages presentes no catkin workspace.  cd ~/catkin_ws\ncatkin_make",
            "title": "Realizando a \"build\" e gerando uma fonte para o arquivo de \"setup\""
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#conhecendo-ros-nodes",
            "text": "",
            "title": "Conhecendo ROS Nodes"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#download-de-simuladores-simples",
            "text": "sudo apt-get install ros-melodic-ros-tutorials",
            "title": "Download de simuladores simples"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#roscore",
            "text": "A primeira a\u00e7\u00e3o a ser feita sempre que for usar o ROS \u00e9 inicializar o Roscore  roscore  Caso o Roscore n\u00e3o inicialize e o terminal retorne uma mensagem sobre falta de permiss\u00f5es, mude recursivamente o \"dono\" da pasta  sudo chown -R <seu_username> ~/.ros",
            "title": "Roscore"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rosrun",
            "text": "O comando rosrun permite que execute uma node em uma determinada package  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosrun [nome_da_package] [nome_da_node]  Agora em um novo terminal, vamos executar a node chamada  turtlesim_node  que inicializa o simulador Turtle Sim.  rosrun turtlesim turtlesim_node",
            "title": "Utilizando o rosrun"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rosnode",
            "text": "O comando  rosnode  mostra informa\u00e7\u00f5es sobre as nodes que est\u00e3o funcionando no momento.  Voc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando (em um novo terminal):  rosnode -h",
            "title": "Utilizando o rosnode"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#conhecendo-ros-topics",
            "text": "",
            "title": "Conhecendo ROS Topics"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#controlando-a-tartaruguinha-do-turtle-sim-pelo-teclado",
            "text": "Ainda com o Turtle Sim aberto, em um novo terminal execute a node chamada  turtle_teleop_key .  rosrun turtlesim turtle_teleop_key  Agora voc\u00ea pode utilizar o teclado para movimentar a tartaruga. Mas para isso, \u00e9 necess\u00e1rio que a tela do terminal onde digitou o comando acima esteja selecionada.",
            "title": "Controlando a tartaruguinha do Turtle Sim pelo teclado"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rqt_graph",
            "text": "As nodes  turtlesim_node  e  turtle_teleop_key  est\u00e3o comunicando uma com a outra por meio de um ROS Topic.  turtle_teleop_key  est\u00e1 \"publicando\" ( publishing ) as entradas em um Topic de quando acionamos o teclado, enquanto  turtlesim_node  est\u00e1 \"lendo\" ou \"inscrevendo\" ( subscribing ) no mesmo Topic para receber o sinal do acionamento do teclado e realizar a a\u00e7\u00e3o no simulador.  Podemos perceber isso utilizando o  rqt_graph  que foi instalado quando instalamos a distribui\u00e7\u00e3o Melodic. Ele possui a fun\u00e7\u00e3o de mostrar por meio de um gr\u00e1fico din\u00e2mico o que est\u00e1 acontecendo no sistema.    Em um novo terminal digite:  rosrun rqt_graph rqt_graph",
            "title": "Utilizando o rqt_graph"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rostopic-echo",
            "text": "O comando  rostopic  mostra informa\u00e7\u00f5es sobre ROS Topics  Voc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:  rostopic -h  rostopic echo  mostra os dados publicados em um Topic  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic echo [topic]  Vamos observar os dados do  command_velocity  publicado pela node  turtle_teleop_key .  rostopic echo /turtle1/cmd_vel",
            "title": "Utilizando o rostopic echo"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rostopic-type",
            "text": "O comando  rostopic_type  retorna o tipo da Message de qualquer Topic sendo publicado.  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic type [topic]  Agora ent\u00e3o digite:  rostopic type /turtle1/cmd_vel  Voc\u00ea deve receber:  geometry_msgs/Twist . Com essa informa\u00e7\u00e3o, n\u00f3s conseguimos ver os detalhes da Message usando o comando  rosmsg :  rosmsg show geometry_msgs/Twist",
            "title": "Utilizando o rostopic type"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rostopic-pub",
            "text": "O comando  rostopic pub  publica algum dado em um Topic funcionando atualmente.  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rostopic pub [topic] [msg_type] [argumentos]  Vamos enviar uma \u00fanica mensagem para o Turtle Sim dizendo a ele para se mover com uma velocidade linear de 2.0 e velocidade angular de 1.8.  rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'  Podemos fazer com que a tartaruga continue se movimentando infinitamente adicionando  -r  no comando:  rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'",
            "title": "Utilizando o rostopic pub"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rqt_plot",
            "text": "O  rqt_plot  gera um gr\u00e1fico que mostra os dados publicados nos Topics ao longo do tempo:  rosrun rqt_plot rqt_plot  Adicione na caixa de texto os Topics  /turtle1/pose/x  e  /turtle1/pose/y  para ver no gr\u00e1fico as posi\u00e7\u00f5es da tartaruga no gr\u00e1fico ao longo do tempo.",
            "title": "Utilizando o rqt_plot"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#conhecendo-ros-services-e-parameters",
            "text": "",
            "title": "Conhecendo ROS Services e Parameters"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rosservice-call",
            "text": "O comando  rosservice  mostra informa\u00e7\u00f5es sobre ROS Services  Voc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:  rosservice -h  O  rosservice call  chama um Service com seus respectivos argumentos  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosservice call [service] [argumentos]  Vamos chamar um Service que limpa o fundo da node  turtlesim_node . Esta a\u00e7\u00e3o n\u00e3o necessita de argumentos.  rosservice call /clear  Agora em um caso onde o Service possui argumentos. Vamos ver quais s\u00e3o eles:  rosservice type /spawn | rossrv show  Esse Service  /spawn  nos permite \"spawnar\" uma nova tartaruga em um dado local e orienta\u00e7\u00e3o. Agora que sabemos os argumentos necess\u00e1rios, vamos \"spawnar\" mais uma tartaruga no simulador:  rosservice call /spawn 2 2 0.2 \"\"",
            "title": "Utilizando o rosservice call"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-rosparam-set-e-o-rosparam-get",
            "text": "O comando  rosparam  mostra informa\u00e7\u00f5es sobre ROS Parameter Services e permite armazenar e manipular seus dados  Voc\u00ea pode conferir que a\u00e7\u00f5es efetuar pelo comando:  rosparam -h  O  rosparam list  mostra os par\u00e2metros da node  turtlesim_node  rosparam list  Agora, podemos mudar e resgatar um dos valores utilizando o  rosparam set  e  rosparam get  respectivamente:  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosparam set [nome_do_par\u00e2metro]\n# rosparam get [nome_do_par\u00e2metro]  Vamos mudar o valor do \"red channel\" do sistema de cor RGB do plano de fundo do simulador:  rosparam set /turtlesim/background_r 150  Para que a mudan\u00e7a fa\u00e7a efeito \u00e9 necess\u00e1rio chamar o Service  clear :  rosservice call /clear  E para visualizar o conte\u00fado do todo Parameter Server utilizamos:  rosparam get /",
            "title": "Utilizando o rosparam set e o rosparam get"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#conhecendo-o-ros-launch",
            "text": "",
            "title": "Conhecendo o ROS Launch"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#utilizando-o-roslaunch",
            "text": "O comando  roslaunch  inicializa nodes definidas em um launch file  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# roslaunch [package] [nome_do_arquivo.launch]  Para uma maior organiza\u00e7\u00e3o vamos criar primeiramente um diret\u00f3rio chamado \"launch\" no qual armazenar\u00e1 os \"launch files\"  source devel/setup.bash\nroscd curso\nmkdir launch\ncd launch  Agora criamos um launch file chamado  turtlemimic.launch  touch turtlemimic.launch  Copie e cole no arquivo o seguinte c\u00f3digo:  <launch>\n\n  <group ns=\"turtlesim1\">\n        <node pkg=\"turtlesim\" name=\"sim\" type=\"turtlesim_node\"/>\n  </group>\n\n  <group ns=\"turtlesim2\">\n        <node pkg=\"turtlesim\" name=\"sim\" type=\"turtlesim_node\"/>\n  </group>\n\n  <node pkg=\"turtlesim\" name=\"mimic\" type=\"mimic\">\n    <remap from=\"input\" to=\"turtlesim1/turtle1\"/>\n    <remap from=\"output\" to=\"turtlesim2/turtle1\"/>\n  </node>\n\n</launch>  Voc\u00ea pode editar o arquivo a partir do comando  rosed  abaixo. (Da mesma forma, abaixo est\u00e1 o comando de instala\u00e7\u00e3o do editor de texto Vim - editor padr\u00e3o do ROS)  sudo apt install vim\nrosed curso turtlemimic.launch  Ap\u00f3s editado o arquivo, vamos execut\u00e1-lo.  roslaunch curso turtlemimic.launch  E em um novo terminal vamos digitar um novo comando  rostopic  rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]'  Podemos entender como foi feito a \"m\u00edmica\" abrindo o  rqt_graph  rqt_graph",
            "title": "Utilizando o roslaunch"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-um-ros-msg-e-srv",
            "text": "",
            "title": "Criando um ROS msg e srv"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-uma-msg",
            "text": "Uma msg \u00e9 armazenada no diret\u00f3rio \"msg\" espec\u00edfico. Portanto, vamos criar um.  source devel/setup.bash\nroscd curso\nmkdir msg\ncd msg  Vamos agora criar e editar uma msg chamada  Num.msg  touch Num.msg\nrosed curso Num.msg  E cole as seguintes tipagens:  int64 num\nstring first_name\nstring last_name\nuint8 age\nuint32 score",
            "title": "Criando uma msg"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#editando-o-packagexml-e-cmakeliststxt",
            "text": "Ap\u00f3s criada a msg, tenha certeza de que no arquivo  package.xml , as seguintes linhas n\u00e3o est\u00e3o comentadas  <build_depend>message_generation</build_depend>\n<exec_depend>message_runtime</exec_depend>  E no arquivo  CMakeLists.txt , adicione a depend\u00eancia  message generation  para que as Messages possam ser geradas.  Voc\u00ea pode fazer isso adicionando na lista de  COMPONENTS  como mostrado abaixo:  # N\u00e3o s\u00f3 adicione isso no arquivo, modifique o texto existente adicionando \"message_generation\" antes dos par\u00eanteses de fechamento.\nfind_package(catkin REQUIRED COMPONENTS\n    roscpp\n    rospy\n    std_msgs\n    message_generation\n)  Da mesma forma, tenha certeza de que esteja exportando a execu\u00e7\u00e3o da depend\u00eancia (removendo o coment\u00e1rio e/ou adicionando as linhas abaixo):  catkin_package(\n...\nCATKIN_DEPENDS message_runtime ...\n...)  Agora remova o coment\u00e1rio das linhas abaixo e substitua as  Message*.msg  por  Num.msg  #Antes\n\n# add_message_files(\n#   FILES\n#   Message1.msg\n#   Message2.msg\n# )\n\n#Depois\n\nadd_message_files(\n  FILES\n  Num.msg\n)  Por fim, precisamos garantir que a func\u00e7\u00e3o  generate_messages ()  \u00e9 chamada. Para isso, remova os coment\u00e1rios das seguintes linhas:  generate_messages(\nDEPENDENCIES\nstd_msgs\n)",
            "title": "Editando o package.xml e CMakeLists.txt"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#testando-a-msg-criada",
            "text": "Vamos ter certeza de que o ROS possa reconhecer a msg usando o comando  rosmsg show   Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rosmsg show [tipo da message]  Testando ent\u00e3o:  rosmsg show curso/Num  Voc\u00ea receber\u00e1 como resposta:  int64 num\nstring first_name\nstring last_name\nuint8 age\nuint32 score",
            "title": "Testando a msg criada"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#criando-um-srv",
            "text": "Uma msg \u00e9 armazenada no diret\u00f3rio \"srv\" espec\u00edfico. Portanto, vamos criar um.  roscd curso\nmkdir srv\ncd srv  Ao inv\u00e9s de criar um srv por n\u00f3s mesmos, vamos copiar um j\u00e1 existente de uma outra package.  Para isso, o comando  roscp  \u00e9 \u00fatil para copiar arquivos de uma package a outra  Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# roscp [nome_da_package] [arquivo_a_copiar] [local_do_arquivo_a_copiar]  Agora podemos copiar um srv da package  ropsy_tutorials  roscp rospy_tutorials AddTwoInts.srv AddTwoInts.srv",
            "title": "Criando um srv"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#editando-o-cmake_liststxt",
            "text": "A depend\u00eancia  message_generation  funciona tanto para msg quanto para srv, como anteriormente j\u00e1 foi configurada, n\u00e3o precisamos realiz\u00e1-la novamente.  A mudan\u00e7a necess\u00e1ria ser\u00e1 a remo\u00e7\u00e3o dos coment\u00e1rios das linhas abaixo e a substitui\u00e7\u00e3o dos  Service*.srv  por  AddTwoInts.srv  que \u00e9 o nome do srv copiado.  #Antes\n\n# add_service_files(\n#   FILES\n#   Service1.srv\n#   Service2.srv\n# )\n\n#Depois\n\nadd_service_files(\n  FILES\n  AddTwoInts.srv\n)",
            "title": "Editando o CMake_Lists.txt"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#testando-o-srv-criado",
            "text": "Vamos ter certeza de que o ROS possa reconhecer o srv usando o comando  rossrv show   Usabilidade:  # Esse \u00e9 um exemplo, n\u00e3o tente rodar esse c\u00f3digo\n# rossrv show [tipo do service]  Testando ent\u00e3o:  rossrv show curso/AddTwoInts  Voc\u00ea receber\u00e1 como resposta:  int64 a\nint64 b\n---\nint64 sum",
            "title": "Testando o srv criado"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#construcao-dos-arquivos-criados",
            "text": "Como criou novas Messages e Services, precisamos fazer a \"build\" da nossa package novamente:  cd\ncd catkin_ws\ncatkin_make",
            "title": "Constru\u00e7\u00e3o dos arquivos criados"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-um-publisher-e-subscriber-simples",
            "text": "",
            "title": "Escrevendo um Publisher e Subscriber simples"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-uma-publisher-node",
            "text": "Vamos criar uma node que ir\u00e1 continuamente transmitir uma Message. Para isso, vamos criar um diret\u00f3rio na nossa package onde ir\u00e1 conter os arquivos fontes ou  source files  roscd curso\nmkdir -p src\ncd src  Vamos agora criar um arquivo chamado  talker.cpp  retirado do site:  https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp   Da mesma forma, vamos abri-lo para podermos analisar o c\u00f3digo presente e transforma-lo em um arquivo execut\u00e1vel.  wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp\nchmod +x talker.cpp\nrosed curso talker.cpp  Caso recebam algum tipo de aviso, role a p\u00e1gina at\u00e9 o final e tecle o bot\u00e3o \"a\" no seu teclado para que possam visualizar o c\u00f3digo",
            "title": "Escrevendo uma Publisher Node"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#analisando-a-publisher",
            "text": "Agora vamos entender o c\u00f3digo  27 #include \"ros/ros.h\"\n28  ros/ros.h  \u00e9 uma conveniente inclus\u00e3o que inclui todas as  headers  necess\u00e1rias para usar as pe\u00e7as p\u00fablicas mais comuns do sistema do ROS  28 #include \"std_msgs/String.h\"\n29  As linhas acima incluem a Message  std_msgs/String  que reside na package  std_msgs . Essa \u00e9 uma  header  gerada automaticamente pelo arquivo  String.msg  presente na package  47   ros::init(argc, argv, \"talker\");  Inicializa o ROS. \u00c9 onde tamb\u00e9m especificamos o nome da nossa node. (Nomes de nodes precisam ser \u00fanicas em um sistema a funcionar)  54   ros::NodeHandle n;  Cria um manipulador ou  handle  para o processamento da node. O primeiro  NodeHandle  criado vai inicializar a node e o \u00faltimo ir\u00e1 destru\u00ed-la limpando os recursos que a node estava usando  73   ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);  Diz para o Master que estaremos publicando uma Message do tipo  std_msgs/String  no Topic  chatter . Permite que o Master diga a qualquer node \"escutando\" no Topic  chatter  que estaremos publicando dados nesse t\u00f3pico. O segundo argumento, \u00e9 o tamanho da fila que estamos publicando. Nesse caso, se estamos publicando muito rapidamente, ele ir\u00e1 \"buffar\" no m\u00e1ximo 1000 Messages antes de come\u00e7ar a descartar as antigas.  NodeHandle::advertise()  retorna um objeto  ros::Publisher  que serve para dois prop\u00f3sitos:   Conter um m\u00e9todo  publish()  que permite que publiquemos Messages dentro do t\u00f3pico que foi criado junto   Quando sair do escopo, ir\u00e1 automaticamente desavisar ( unadvertise )  75   ros::Rate loop_rate(10);    Um objeto  ros::Rate  permite especificar a frequ\u00eancia que voc\u00ea gostaria que o ciclo possua. Ele ir\u00e1 verificar quanto tempo se passou at\u00e9 que a \u00faltima chamada ao  ros::sleep()  foi feita. Da mesma forma, \"dorme\" ( sleep ) por um correta quantidade de tempo.  Nesse caso, dizemos a ele que queremos funcionar a 10Hz.  81   int count = 0;\n82   while (ros::ok())\n83   {  Por padr\u00e3o,  roscpp  instalar\u00e1 um manipulador SIGINT que providenciar\u00e1 o desligamento da manipula\u00e7\u00e3o, que no caso ir\u00e1 causar  ros::ok()  retornar falso.  ros::ok()  retornar\u00e1 falso se:   Um SIGINT \u00e9 recebido;  Fomos expulsos da rede por uma outra node de mesmo nome;  ros::shutdown()  foi chamado por outra parte da aplica\u00e7\u00e3o;  Todos os  ros::NodeHandles  foram destru\u00eddos.   Uma vez que  ros::ok  retorne falso, todas as chamadas do ROS ir\u00e3o falhar  87     std_msgs::String msg;\n88 \n89     std::stringstream ss;\n90     ss << \"hello world \" << count;\n91     msg.data = ss.str();  Transmitimos uma mensagem no ROS usando uma classe de mensagens-adaptadas, usualmente gerada por um arquivo msg.   datatypes  mais complicados s\u00e3o poss\u00edveis, mas por agora iremos usar uma Message String padr\u00e3o, que possui um membro \"dado\".  101     chatter_pub.publish(msg);  Agora n\u00f3s estamos realmente transmitindo a Message a todos que est\u00e3o conectados  93     ROS_INFO(\"%s\", msg.data.c_str());  ROS_INFO  e amigos s\u00e3o os os nossos substitutos para o  printf/cout  103     ros::spinOnce();  Chamando o  ros::spinOnce()  aqui, n\u00e3o \u00e9 necess\u00e1rio para este programa simples pois n\u00e3o estamos recebendo nenhum  callback . Entretanto, se voc\u00ea for adicionar uma \"subscription\" nessa aplica\u00e7\u00e3o, e n\u00e3o tem o  ros::spinOnce()  aqui, seus  callbacks  nunca ser\u00e3o chamados. Ent\u00e3o , adicion\u00e1-lo \u00e9 uma boa medida  105     loop_rate.sleep();  Agora usamos o objeto  ros::Rate  para \"dormir\" ( sleep ) pelo tempo restante que nos permite alcan\u00e7ar a taxa de \"publish\" de 10Hz desejada.  Abaixo h\u00e1 uma vers\u00e3o condensada do que est\u00e1 acontecendo   Inicializa o sistema do ROS  Avisa se vamos publicar Messages  std_msgs/String  no Topic  chatter  para o Master  \"Loop\" enquanto publicamos Messages ao  chatter  10 vezes por segundo",
            "title": "Analisando a Publisher"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-um-subscriber-node",
            "text": "Agora precisamos escrever uma Node que receba as Messages  Dentro do diret\u00f3rio src anteriormente criado vamos criar um arquivo chamado  listener.cpp  retirado do site:  https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp   Da mesma forma, vamos abri-lo para podermos analisar o c\u00f3digo presente e transforma-lo em um arquivo execut\u00e1vel.  wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp\nchmod +x listener.cpp\nrosed curso listener.cpp  Caso recebam algum tipo de aviso, role a p\u00e1gina at\u00e9 o final e tecle o bot\u00e3o \"a\" no seu teclado para que possam visualizar o c\u00f3digo",
            "title": "Escrevendo um Subscriber Node"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#analisando-o-subscriber",
            "text": "Vamos analisar o c\u00f3digo ignorando algumas partes que j\u00e1 foram explicadas anteriormente  34 void chatterCallback(const std_msgs::String::ConstPtr& msg)\n35 {\n36   ROS_INFO(\"I heard: [%s]\", msg->data.c_str());\n37 }  Essa \u00e9 a fun\u00e7\u00e3o de  callback  que ser\u00e1 chamada quando uma nova Message chegar no Topic  chatter . A Message \u00e9 passada em um  boost shared_ptr  que significa que voc\u00ea pode armazen\u00e1-lo se quiser, sem preocupar se est\u00e1 sendo deletado abaixo de voc\u00ea e sem copiar o dado subjacente.  75   ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback);  \"Subscribe\" no Topic  chatter  com o Master. ROS ir\u00e1 chamar a fun\u00e7\u00e3o  chatterCallback()  sempre que uma nova mensagem chega. O segundo argumento \u00e9 o tamanho da fila, no caso de n\u00e3o ser poss\u00edvel processar Messages r\u00e1pido o suficiente. Nesse caso, se a fila chega a 1000 Messages, come\u00e7aremos a descartar velhas Messages enquanto novas chegam.  NodeHandle::subscribe()  retorna um objeto  ros::Subscriber  que voc\u00ea precisa manter at\u00e9 o momento que desejar se desinscrever ( unsubscribe ). Quando o objeto Subscriber \u00e9 destru\u00eddo, ele ir\u00e1 automaticamente se desinscrever do Topic  chatter   Existem vers\u00f5es da fun\u00e7\u00e3o  NodeHandle::subscribe()  que permite especificar membros da classe, ou at\u00e9 qualquer coisa capaz de ser chamada pelo objeto  Boost.Function  82   ros::spin();  ros::spin()  entra em um loop, chamando  callbacks  de Messages o mais r\u00e1pido poss\u00edvel. Mas n\u00e3o se preocupe, se n\u00e3o existe nada a ser feito ele n\u00e3o ir\u00e1 usar muita CPU.  ros::spin()  ir\u00e1 sair uma vez que  ros::ok()  retorne falso, o que significa que  ros::shutdown()  foi chamado, ou pelo  handler  de desligamento (o Master nos dizendo para desligar), ou sendo chamado manualmente.  Existem outras formas de puxar  callbacks , mas n\u00e3o iremos preocupar com elas por agora.  Novamente, abaixo est\u00e1 uma vers\u00e3o condensada do que est\u00e1 acontecendo:   Inicia o sistema do ROS;  Se inscreve no Topic  chatter ;  \"Spin\", esperando a chegada de Messages;  Quando uma Message chega, a fun\u00e7\u00e3o  chatterCallback() \u00e9 chamada.",
            "title": "Analisando o Subscriber"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#construindo-as-nodes",
            "text": "Editando novamente o arquivo  CMakeLists.txt , retirando coment\u00e1rios e adicionando linhas de c\u00f3digo, o conte\u00fado deve estar mais ou menos assim:   (Mantendo as modifica\u00e7\u00f5es feitas nos passos anteriores)  cmake_minimum_required(VERSION 2.8.3)\nproject(curso)\n\n## Find catkin and any catkin packages\nfind_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation)\n\n## Declare ROS messages and services\nadd_message_files(FILES Num.msg)\nadd_service_files(FILES AddTwoInts.srv)\n\n## Generate added messages and services\ngenerate_messages(DEPENDENCIES std_msgs)\n\n## Declare a catkin package\ncatkin_package()\n\n## Build talker and listener\ninclude_directories(include ${catkin_INCLUDE_DIRS})\n\nadd_executable(talker src/talker.cpp)\ntarget_link_libraries(talker ${catkin_LIBRARIES})\nadd_dependencies(talker curso_generate_messages_cpp)\n\nadd_executable(listener src/listener.cpp)\ntarget_link_libraries(listener ${catkin_LIBRARIES})\nadd_dependencies(listener curso_generate_messages_cpp)  As \u00faltimas 6 linhas de c\u00f3digo adicionadas ir\u00e3o criar dois execut\u00e1veis,  talker  e  listener  que por padr\u00e3o ir\u00e3o para o diret\u00f3rio  devel   Note que voce teve que adicionar duas depend\u00eancias para os \"executable targets\" aos \"message generation targets\"  add_dependencies(talker curso_generate_messages_cpp)  Isso garante que as \"messages headers\" dessa package sejam geradas antes de us\u00e1-las. Se voc\u00ea usar Messages de outras Packages de dentro do seu catkin workspace, voc\u00ea precisa adicionar depend\u00eancias para os seus respectivos \"generations targets\" tamb\u00e9m, pois o catkin constroi todos os projetos em paralelo. Assim como  Groovy  voc\u00ea pode usar a seguinte vari\u00e1vel para depender de todos os alvos necess\u00e1rios:  target_link_libraries(talker ${catkin_LIBRARIES})  Ent\u00e3o agora voc\u00ea pode faze a \"build\"  cd\ncd catkin_ws\ncatkin_make",
            "title": "Construindo as Nodes"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#testando-o-publisher-e-subscriber-criados",
            "text": "Tenha certeza que roscore esteja ativo. Em um novo terminal  roscore  Tenha certeza que fez a \"source\" do seu arquivo do workspace  setup.sh  cd\ncd catkin_ws\nsource devel/setup.bash  Vamos agora testar o Publisher  talker  rosrun curso talker  Voc\u00ea ir\u00e1 receber algo parecido com isso:  [INFO] [WallTime: 1314931831.774057] hello world 1314931831.77\n[INFO] [WallTime: 1314931832.775497] hello world 1314931832.77\n[INFO] [WallTime: 1314931833.778937] hello world 1314931833.78\n[INFO] [WallTime: 1314931834.782059] hello world 1314931834.78\n[INFO] [WallTime: 1314931835.784853] hello world 1314931835.78\n[INFO] [WallTime: 1314931836.788106] hello world 1314931836.79  Agora em um novo terminal, vamos testar o Subscriber  listener  rosrun curso listener  Voc\u00ea receber\u00e1 algo parecido com isso:  [INFO] [WallTime: 1314931969.258941] /listener_17657_1314931968795I heard hello world 1314931969.26\n[INFO] [WallTime: 1314931970.262246] /listener_17657_1314931968795I heard hello world 1314931970.26\n[INFO] [WallTime: 1314931971.266348] /listener_17657_1314931968795I heard hello world 1314931971.26\n[INFO] [WallTime: 1314931972.270429] /listener_17657_1314931968795I heard hello world 1314931972.27\n[INFO] [WallTime: 1314931973.274382] /listener_17657_1314931968795I heard hello world 1314931973.27\n[INFO] [WallTime: 1314931974.277694] /listener_17657_1314931968795I heard hello world 1314931974.28\n[INFO] [WallTime: 1314931975.283708] /listener_17657_1314931968795I heard hello world 1314931975.28  Ap\u00f3s feitos os testes pode apertar Ctrl-C para finalizar ambas as Nodes.",
            "title": "Testando o Publisher e Subscriber criados"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-um-service-e-client-simples",
            "text": "",
            "title": "Escrevendo um Service e Client simples"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-um-service-node",
            "text": "Vamos criar um Service Node  add_two_ints_server  que receber\u00e1 dois inteiros e retorna a soma. Ele estar\u00e1 armazenado no diret\u00f3rio src criado nos passos anteriores.  roscd curso/src\ntouch add_two_ints_server.cpp  Agora vamos edit\u00e1-lo e transforma-lo em um arquivo execut\u00e1vel.  chmod +x add_two_ints_server.cpp\nrosed curso add_two_ints_server.cpp  Cole o seguinte c\u00f3digo no arquivo:  #include \"ros/ros.h\"\n#include \"curso/AddTwoInts.h\"\n\nbool add(curso::AddTwoInts::Request  &req,\n         curso::AddTwoInts::Response &res)\n{\n  res.sum = req.a + req.b;\n  ROS_INFO(\"request: x=%ld, y=%ld\", (long int)req.a, (long int)req.b);\n  ROS_INFO(\"sending back response: [%ld]\", (long int)res.sum);\n  return true;\n}\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"add_two_ints_server\");\n  ros::NodeHandle n;\n\n  ros::ServiceServer service = n.advertiseService(\"add_two_ints\", add);\n  ROS_INFO(\"Ready to add two ints.\");\n  ros::spin();\n\n  return 0;\n}",
            "title": "Escrevendo um Service Node"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#analisando-o-service",
            "text": "Vamos agora entender o c\u00f3digo  1 #include \"ros/ros.h\"\n2 #include \"curso/AddTwoInts.h\"\n3  curso/AddTwoInts.h  \u00e9 o arquivo  header  gerado do arquivo srv que criamos nos passos anteriores.  4 bool add(curso::AddTwoInts::Request  &req,\n5          curso::AddTwoInts::Response &res)  Essa fun\u00e7\u00e3o providencia o Service que adiciona dois inteiros. Ele recebe o tipo de \"solicita\u00e7\u00e3o\" ( request ) e de \"resposta\" ( response ) definido no arquivo srv e retorna um booleano.  6 {\n7   res.sum = req.a + req.b;\n8   ROS_INFO(\"request: x=%ld, y=%ld\", (long int)req.a, (long int)req.b);\n9   ROS_INFO(\"sending back response: [%ld]\", (long int)res.sum);\n10   return true;\n11 }  Acima, os dois inteiros s\u00e3o adicionados e armazenados na \"resposta\". Depois, algumas informa\u00e7\u00f5es sobre a \"solicita\u00e7\u00e3o\" e a \"resposta\" s\u00e3o registrados. Por fim, o Service retorna verdadeiro quando completo  18   ros::ServiceServer service = n.advertiseService(\"add_two_ints\", add);  Acima, o Service \u00e9 criado e anunciado sobre o ROS",
            "title": "Analisando o Service"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#escrevendo-um-client-node",
            "text": "Vamos criar um Service Node  add_two_ints_client . Ele estar\u00e1 armazenado novamente no diret\u00f3rio src.  roscd curso/src\ntouch add_two_ints_client.cpp  Agora vamos edit\u00e1-lo e transforma-lo em um arquivo execut\u00e1vel  chmod +x add_two_ints_client.cpp\nrosed curso add_two_ints_client.cpp  Cole o seguinte c\u00f3digo no arquivo:  #include \"ros/ros.h\"\n#include \"curso/AddTwoInts.h\"\n#include <cstdlib>\n\nint main(int argc, char **argv)\n{\n  ros::init(argc, argv, \"add_two_ints_client\");\n  if (argc != 3)\n  {\n    ROS_INFO(\"usage: add_two_ints_client X Y\");\n    return 1;\n  }\n\n  ros::NodeHandle n;\n  ros::ServiceClient client = n.serviceClient<curso::AddTwoInts>(\"add_two_ints\");\n  curso::AddTwoInts srv;\n  srv.request.a = atoll(argv[1]);\n  srv.request.b = atoll(argv[2]);\n  if (client.call(srv))\n  {\n    ROS_INFO(\"Sum: %ld\", (long int)srv.response.sum);\n  }\n  else\n  {\n    ROS_ERROR(\"Failed to call service add_two_ints\");\n    return 1;\n  }\n\n  return 0;\n}",
            "title": "Escrevendo um Client Node"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#analisando-o-client",
            "text": "Vamos agora entender o c\u00f3digo  15   ros::ServiceClient client = n.serviceClient<curso::AddTwoInts>(\"add_two_ints\");  A linha acima cria um Client para o Service  add_two_ints . O objeto  ros::ServiceClient  \u00e9 usado para chamar o Service posteriormente  16   curso::AddTwoInts srv;\n17   srv.request.a = atoll(argv[1]);\n18   srv.request.b = atoll(argv[2]);  Acima, n\u00f3s instaciamos um Service Class que se \"autogera\" e atribui valores dentro de seu membro de \"solicita\u00e7\u00e3o\". Um Service Class cont\u00e9m dois membros,  request  e  response . Ele da mesma forma cont\u00e9m duas defini\u00e7\u00f5es de classe  Request  e  Response .  19   if (client.call(srv))  A linha acima realmente chama o Service. Desde que as chamadas do Service s\u00e3o bloqueadas, ele retornar\u00e1 uma vez que a chamada \u00e9 finalizada. Se a chamada do Service for bem sucedida,  call()  ir\u00e1 retornar verdadeiro e o valor em  srv.response  ser\u00e1 valido. Se a chamada n\u00e3o for bem sucedida ,  call()  retornar\u00e1 falso e o valor em  srv.response  ser\u00e1 inv\u00e1lido.",
            "title": "Analisando o Client"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#construindo-as-nodes_1",
            "text": "Novamente, ser\u00e1 necess\u00e1rio editar o arquivo  CMakeLists.txt , adicionando no final do arquivo o seguinte c\u00f3digo:  add_executable(add_two_ints_server src/add_two_ints_server.cpp)\ntarget_link_libraries(add_two_ints_server ${catkin_LIBRARIES})\nadd_dependencies(add_two_ints_server curso_gencpp)\n\nadd_executable(add_two_ints_client src/add_two_ints_client.cpp)\ntarget_link_libraries(add_two_ints_client ${catkin_LIBRARIES})\nadd_dependencies(add_two_ints_client curso_gencpp)  As linhas acima ir\u00e3o criar dois execut\u00e1veis,  add_two_ints_server  e  add_two_ints_client  que por padr\u00e3o ir\u00e3o para seu diret\u00f3rio  devel .  Agora, podemos fazer a \"build\" novamente  cd\ncd catkin_ws\ncatkin_make",
            "title": "Construindo as Nodes"
        },
        {
            "location": "/Cursos/Introdu\u00e7\u00e3o-ao-ROS-e-Gazebo/#testando-o-service-e-client-criados",
            "text": "Tenha certeza que roscore esteja ativo. Em um novo terminal  roscore  Tenha certeza que fez a \"source\" do seu arquivo do workspace  setup.sh  cd catkin_ws\nsource devel/setup.bash  Vamos agora testar o server  rosrun curso add_two_ints_server  Voc\u00ea ir\u00e1 receber algo parecido com isso:  Ready to add two ints.  Agora em um outro terminal, vamos colocar para funcionar o client com os argumentos necess\u00e1rios  rosrun curso add_two_ints_client 1 3  No terminal do client, voc\u00ea ir\u00e1 receber algo parecido com isso:  Sum: 4  E no terminal do server, algo parecido com isso:  request: x=1, y=3\nsending back response: [4]",
            "title": "Testando o Service e Client criados"
        }
    ]
}